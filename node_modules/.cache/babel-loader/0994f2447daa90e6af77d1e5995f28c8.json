{"ast":null,"code":"import _asyncToGenerator from \"/home/michael/git/enqrypt-it/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/michael/git/enqrypt-it/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/michael/git/enqrypt-it/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/home/michael/git/enqrypt-it/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js\";\n\n/*\n * This script simplifieds the process of encoding and decoding strings with javascript's built-in \n * encryption features (crypto.subtle). Crypto.subtle can't directly encrypt or decrypt strings; they must first be converted\n * to (for encryption) or from (after decryption) ArrayBuffers. \n */\nvar subtleCrypto = window.crypto.subtle;\nvar keyConfig = {\n  name: \"RSA-OAEP\",\n  modulusLength: 4096,\n  publicExponent: new Uint8Array([1, 0, 1]),\n  hash: \"SHA-256\"\n};\nvar encryptionParams = {\n  name: \"RSA-OAEP\"\n};\n\nvar StringEncryptorDecryptor = /*#__PURE__*/function () {\n  function StringEncryptorDecryptor(encryptionKey) {\n    _classCallCheck(this, StringEncryptorDecryptor);\n\n    this.encoder = void 0;\n    this.decoder = void 0;\n    this.encryptionKey = void 0;\n\n    if (encryptionKey === null || encryptionKey === undefined) {\n      this.encryptionKey = null;\n      this.generateKey();\n    } else {\n      this.encryptionKey = encryptionKey;\n    }\n\n    this.encoder = new TextEncoder();\n    this.decoder = new TextDecoder();\n  }\n\n  _createClass(StringEncryptorDecryptor, [{\n    key: \"generateKey\",\n    value: function () {\n      var _generateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return subtleCrypto.generateKey(keyConfig, true, [\"encrypt\", \"decrypt\"]);\n\n              case 2:\n                this.encryptionKey = _context.sent;\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function generateKey() {\n        return _generateKey.apply(this, arguments);\n      }\n\n      return generateKey;\n    }()\n  }, {\n    key: \"encryptString\",\n    value: function () {\n      var _encryptString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(str, key) {\n        var selectedKey, unencryptedMessage, encryptedMessage, encryptedMessageString;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(key !== undefined)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                selectedKey = key;\n                _context2.next = 9;\n                break;\n\n              case 4:\n                if (!(this.encryptionKey !== null)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                selectedKey = this.encryptionKey.publicKey;\n                _context2.next = 9;\n                break;\n\n              case 8:\n                throw new Error(\"Encryption key has not finished generating.\");\n\n              case 9:\n                unencryptedMessage = this.encoder.encode(str); // Encrypt the message\n\n                _context2.prev = 10;\n                _context2.next = 13;\n                return subtleCrypto.encrypt(encryptionParams, selectedKey, unencryptedMessage);\n\n              case 13:\n                encryptedMessage = _context2.sent;\n                _context2.next = 19;\n                break;\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](10);\n                throw _context2.t0;\n\n              case 19:\n                encryptedMessageString = this.decoder.decode(encryptedMessage);\n                return _context2.abrupt(\"return\", {\n                  encryptedString: encryptedMessageString,\n                  encryptionKey: key\n                });\n\n              case 21:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[10, 16]]);\n      }));\n\n      function encryptString(_x, _x2) {\n        return _encryptString.apply(this, arguments);\n      }\n\n      return encryptString;\n    }()\n  }, {\n    key: \"decryptArrayBuffer\",\n    value: function () {\n      var _decryptArrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(arrayBufferMessage, key) {\n        var selectedKey, decryptedMessage, decryptedMessageString;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(key !== undefined)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                selectedKey = key;\n                _context3.next = 9;\n                break;\n\n              case 4:\n                if (!(this.encryptionKey !== null)) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                selectedKey = this.encryptionKey.privateKey;\n                _context3.next = 9;\n                break;\n\n              case 8:\n                throw new Error(\"Encryption key has not finished generating.\");\n\n              case 9:\n                if (!(this.encryptionKey !== null)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                _context3.next = 12;\n                return subtleCrypto.decrypt(encryptionParams, selectedKey, arrayBufferMessage);\n\n              case 12:\n                decryptedMessage = _context3.sent;\n                decryptedMessageString = this.decoder.decode(decryptedMessage);\n                return _context3.abrupt(\"return\", decryptedMessageString);\n\n              case 17:\n                throw new Error(\"Encryption key has not finished generating!\");\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function decryptArrayBuffer(_x3, _x4) {\n        return _decryptArrayBuffer.apply(this, arguments);\n      }\n\n      return decryptArrayBuffer;\n    }()\n  }]);\n\n  return StringEncryptorDecryptor;\n}();\n\nexport default StringEncryptorDecryptor;","map":{"version":3,"sources":["/home/michael/git/enqrypt-it/src/Tools/StringEncryptorDecryptor.ts"],"names":["subtleCrypto","window","crypto","subtle","keyConfig","name","modulusLength","publicExponent","Uint8Array","hash","encryptionParams","StringEncryptorDecryptor","encryptionKey","encoder","decoder","undefined","generateKey","TextEncoder","TextDecoder","str","key","selectedKey","publicKey","Error","unencryptedMessage","encode","encrypt","encryptedMessage","encryptedMessageString","decode","encryptedString","arrayBufferMessage","privateKey","decrypt","decryptedMessage","decryptedMessageString"],"mappings":"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","sourcesContent":["/*\n * This script simplifieds the process of encoding and decoding strings with javascript's built-in \n * encryption features (crypto.subtle). Crypto.subtle can't directly encrypt or decrypt strings; they must first be converted\n * to (for encryption) or from (after decryption) ArrayBuffers. \n */\n \nexport type EncryptedData = {\n  encryptedString: string,\n  encryptionKey: CryptoKey\n}\n \nconst subtleCrypto = window.crypto.subtle;\nconst keyConfig = {\n  name: \"RSA-OAEP\",\n  modulusLength: 4096,\n  publicExponent: new Uint8Array([1,0,1]),\n  hash: \"SHA-256\"\n}\nconst encryptionParams = {\n  name: \"RSA-OAEP\"\n}\n\nclass StringEncryptorDecryptor {\n  encoder: TextEncoder;\n  decoder: TextDecoder;\n  encryptionKey: CryptoKeyPair | null;\n  \n  constructor(encryptionKey?: CryptoKeyPair){\n    if(encryptionKey === null || encryptionKey === undefined){\n      this.encryptionKey = null;\n      this.generateKey();\n    } else {\n      this.encryptionKey = encryptionKey;\n    }\n    this.encoder = new TextEncoder();\n    this.decoder = new TextDecoder();\n  }\n  \n  async generateKey() {\n    this.encryptionKey = await subtleCrypto.generateKey(keyConfig, true, [\"encrypt\", \"decrypt\"]);\n  }\n  \n  async encryptString(str: string, key?: CryptoKey): Promise<EncryptedData | null>{\n    let selectedKey: CryptoKey;\n    if(key !== undefined){\n      selectedKey = key;\n    } else if(this.encryptionKey !== null){\n      selectedKey = this.encryptionKey.publicKey as CryptoKey;\n    } else {\n      throw new Error(\"Encryption key has not finished generating.\");\n    }\n\n    const unencryptedMessage = this.encoder.encode(str);\n    \n    // Encrypt the message\n    let encryptedMessage: ArrayBuffer;\n    try{\n      encryptedMessage = await subtleCrypto.encrypt(encryptionParams, selectedKey, unencryptedMessage);\n    } catch(e){\n      throw e;\n    }\n    const encryptedMessageString = this.decoder.decode(encryptedMessage);\n    return {encryptedString: encryptedMessageString, encryptionKey: key as CryptoKey};\n  }\n  \n  async decryptArrayBuffer(arrayBufferMessage: ArrayBuffer, key?: CryptoKey): Promise<string>{\n    let selectedKey: CryptoKey;\n    if(key !== undefined){\n      selectedKey = key;\n    } else if(this.encryptionKey !== null){\n      selectedKey = this.encryptionKey.privateKey as CryptoKey;\n    } else {\n      throw new Error(\"Encryption key has not finished generating.\");\n    }\n    // Decrypt the message into ArrayBuffer\n    let decryptedMessage: ArrayBuffer;\n    if(this.encryptionKey !== null){\n      decryptedMessage = await subtleCrypto.decrypt(encryptionParams, selectedKey, arrayBufferMessage);\n      let decryptedMessageString = this.decoder.decode(decryptedMessage);\n      return decryptedMessageString;\n    } else {\n      throw new Error(\"Encryption key has not finished generating!\");\n    }\n  }\n}\n \nexport default StringEncryptorDecryptor;"]},"metadata":{},"sourceType":"module"}